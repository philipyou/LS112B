C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE YC_PERIPHERAL
OBJECT MODULE PLACED IN out/YC_Peripheral.obj
COMPILER INVOKED BY: C:\Keil51\c51\bin\C51.exe YC_Peripheral.c OBJECT(out/YC_Peripheral.obj) OBJECTADVANCED OPTIMIZE(9,S
                    -PEED) BROWSE CODE SYMBOLS DF(ENABLE_APE) PR(out/YC_Peripheral.lst) OT(7,SPEED) LARGE

line level    source

   1          #include <string.h>
   2          #include "YC_Define.h"
   3          #include "hwreg.h"
   4          #include "YC_Utilities.h"
   5          #include "YC_Peripheral.h"
   6          //#include "btreg.h"
   7          //#include "YC_Sys.h"
   8          #include "Reg320.h"
   9          #include <intrins.h>
  10          #ifdef YC_PERIPHERAL_LED
              u8_t xdata YC_LedBlinkTimerID;
              LOCAL YC_LedBlink_t xdata YC_LedBlink;
              #endif
  14          
  15          #ifdef YC_PERIPHERAL_EEPROM
              LOCAL volatile u8_t xdata YC_IICDTbuf[4]  _at_ mem_iicd_tbuf;
              #endif
  18          
  19          
  20          #ifdef YC_PERIPHERAL_EEPROM
              void YC_WaitIICDone(void);
              #endif
  23          void YC_LedOffCallback(void);
  24          
  25          #ifdef YC_PERIPHERAL_ADC
              /*===============ADC=============================*/
              
              u16_t YC_ReadADC(YC_ADCChannel_e channel)
              {
                      u16_t x2;
                      REG_RF_ADC_GC = 0xaa;
                      REG_RFEN_ADC=0x7c;
                      REG_GPIO_SEL(0) = 1<<channel;
                      REG_RFEN_CHGPUMP &= 0xf8;
                      REG_RFEN_CHGPUMP |= channel;
                      _nop_();
                      _nop_();
                      _nop_();
                      REG_RFEN_ADC=0x78;
                      _nop_();
                      _nop_();
                      _nop_();
                      x2=ESWAP(REG_ADC_IN)&0x03ff;
                      REG_RFEN_ADC=0x7c;
                      return x2;
              }
              
              #endif
  49          
  50          /*===============SPI FLASH======================================================================*/
  51          
  52          
  53          
  54          
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 2   

  55          
  56          /*===============EEPROM======================================================================*/
  57          #ifdef YC_PERIPHERAL_EEPROM
              
              
              void YC_EepromRead(u16_t addr, u16_t len, u8_t* pbuff)
              {
                      u16_t mem_src =  addr;
                      REG_IICD_TXLEN = ESWAP(4);
                      YC_IICDTbuf[0] = 0xa0;
                      *(u16_t*)(YC_IICDTbuf+1) = mem_src;
                      YC_IICDTbuf[3] = 0xa1;
                      REG_IICD_TXADDR = ESWAP((u16_t)&YC_IICDTbuf);
                      REG_IICD_RXLEN = ESWAP(len);
                      REG_IICD_RXADDR = ESWAP((u16_t)pbuff);
                      REG_IICD_CTRL = 2;
                      if(!(REG_IICD_RXADDR&(1<<7)))
                      {
                              REG_IICD_CTRL |= 1;
                      }
                      REG_MISC_CTRL |= 1 << 2;        //start iic dma
                      YC_WaitIICDone();       
              }
              
              LOCAL u16_t min(u16_t num1,u16_t num2)
              {
                      if(num1<num2)
                              return num1;
                      return num2;
              }
              
              void YC_EepromWrite(u16_t addr, u16_t len, u8_t* pbuff)
              {
                      u16_t current_len;
                      while(len)
                      {
                              current_len =  (addr|(EEP_PAZE_SIZE-1)) +1 - addr;
                              
                              current_len = min (current_len,len);
                      //      current_len = (current_len<len)?current_len:len;
                              len -= current_len;
                              YC_Delay10ms(1);
                              YC_IICWrite(addr,current_len,pbuff);
                              pbuff += current_len;
                              addr  += current_len;
                      };
              }
              
              
              LOCAL void YC_WaitIICDone(void)
              {
                      while(!(REG_DMA_STATUS&(1<<5)));
              }
              /*
              void YC_IICRead(u8_t dev_addr, u16_t len, u8_t* pbuff)
              {
                      REG_IICD_TXLEN = ESWAP(1);
                      REG_IICD_TXADDR = ESWAP((u16_t)&dev_addr);
                      REG_IICD_RXLEN = ESWAP(len);
                      REG_IICD_RXADDR = ESWAP((u16_t)pbuff);
                      REG_IICD_CTRL = 1;
                      REG_MISC_CTRL |= 1 << 2;        //start iic dma
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 3   

                      YC_WaitIICDone();       
              }
              */
              void YC_IICWrite(u16_t dev_addr,u16_t len, u8_t* pbuff)
              {
                      byte ptemp_addr[MAX_IICD_WRITE_LENGTH];
                      ptemp_addr[0] = 0xa0;
                      xmemcpy(ptemp_addr+3, pbuff, len);
                      (u16_t)(ptemp_addr[1]) = dev_addr;
                      
              //      YC_Delay10ms(1);
              
                      REG_IICD_TXLEN = ESWAP(len+3);
                      REG_IICD_TXADDR = ESWAP((u16_t)ptemp_addr);
                      REG_IICD_RXLEN = 0;
                      REG_IICD_CTRL = 1;
              
                      REG_MISC_CTRL |= 1 << 2;        //start iic dma
                      YC_WaitIICDone();       
              }
              #endif
 138          /*===================GPIO========================================================================*/
 139          
 140          bool YC_GPIOGetInputStatus(u8_t gpio_num)
 141          {
 142   1              u8_t queue, group;
 143   1      
 144   1              queue = (gpio_num & 7);
 145   1              group = (gpio_num>>3 & 3);
 146   1      
 147   1              return (REG_GPIO_IN(group) & (1<<queue));
 148   1      }
 149          
 150          #if 0
              void YC_GPIOSetBit(u8_t gpio_num, char *reg_base, bool bit_val)
              {
                      u8_t queue, group;
              
                      queue = (gpio_num & 7);
                      group = gpio_num >> 3 & 3;
              
                      if(bit_val)
                      {
                              *(reg_base + group) |= 1<<queue;
                      }
                      else
                      {
                              *(reg_base + group) &= ~(1<<queue);
                      }
              }
              
              void YC_GPIOSetPullup(u8_t gpio_num, bool bit_val)
              {
                      YC_GPIOSetBit(gpio_num, &REG_GPIO_PUP(0), bit_val);     
              }
              
              void YC_GPIOSetPulldown(u8_t gpio_num, bool bit_val)
              {
                      YC_GPIOSetBit(gpio_num, &REG_GPIO_PDN(0), bit_val);     
              }
              
              void YC_GPIOSetOe(u8_t gpio_num, bool bit_val)
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 4   

              {
                      YC_GPIOSetBit(gpio_num, &REG_GPIO_OE(0), bit_val);      
              }
              
              void YC_GPIOSetOut(u8_t gpio_num, bool bit_val)
              {
                      YC_GPIOSetBit(gpio_num, &REG_GPIO_OUT(0), bit_val);     
              }
              
              void YC_GPIOSet(u8_t gpio_num, bool pup_bit_val ,bool  pdn_bit_val , bool oe_bit_val , bool out_bit_val)
              {
                      
                      YC_GPIOSetBit(gpio_num,&REG_GPIO_PUP(0),pup_bit_val);
                      
                      YC_GPIOSetBit(gpio_num,&REG_GPIO_PDN(0),pdn_bit_val);
              
                      YC_GPIOSetBit(gpio_num,&REG_GPIO_OE(0),oe_bit_val);
              
                      YC_GPIOSetBit(gpio_num,&REG_GPIO_OUT(0),out_bit_val);
              }
              #endif
 200          
 201          /*
 202          void YC_GPIOSetHighWakeup(u8_t gpio_num)
 203          {
 204                  u8_t queue, group;
 205          
 206                  queue = (gpio_num & 7);
 207                  group = (gpio_num>>3 & 3);
 208          
 209                  *(YC_GPIOWakeupL+group) &= ~(1<<queue);
 210                  *(YC_GPIOWakeupH+group) |= 1<<queue;    //high wakeup
 211          }
 212          
 213          
 214          
 215          void YC_GPIOSetLowWakeup(u8_t gpio_num)
 216          {
 217                  u8_t queue, group;
 218          
 219                  queue = (gpio_num & 7);
 220                  group = (gpio_num>>3 & 3);
 221          
 222                  *(YC_GPIOWakeupL+group) |= 1<<queue;    //low wakeup
 223                  *(YC_GPIOWakeupH+group) &= ~(1<<queue);
 224          }
 225          
 226          
 227          void YC_GPIOClearWakeup(u8_t gpio_num)
 228          {
 229                  u8_t queue, group;
 230          
 231                  queue = (gpio_num & 7);
 232                  group = (gpio_num>>3 & 3);
 233                  
 234                  *(YC_GPIOWakeupH+group) &= ~(1<<queue);
 235                  *(YC_GPIOWakeupL+group) &= ~(1<<queue);
 236          }
 237          
 238          */
 239          /*==============LED======================================================================*/
 240          #ifdef YC_PERIPHERAL_LED
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 5   

              void YC_LedOn(u8_t gpio_num, bool active_state)
              {
                      YC_GPIOSetBit(gpio_num, &REG_GPIO_OE(0), 1);
                      YC_GPIOSetBit(gpio_num, &REG_GPIO_OUT(0), active_state);
              }
              
              void YC_LedOff(u8_t gpio_num, bool active_state)
              {
                      YC_GPIOSetBit(gpio_num, &REG_GPIO_OE(0), 1);
                      YC_GPIOSetBit(gpio_num, &REG_GPIO_OUT(0), !active_state);
              }
              
              void YC_LedOnCallback(void)
              {
                      YC_LedOn(YC_LedBlink.gpio_num, YC_LedBlink.active_state);
                      YC_UtilTimerStartMs(YC_LedBlink.light_time, YC_LedOffCallback, &YC_LedBlinkTimerID);
              
              }
              
              void YC_LedOffCallback(void)
              {
                      YC_LedOff(YC_LedBlink.gpio_num, YC_LedBlink.active_state);
                      YC_UtilTimerStartMs(YC_LedBlink.dark_time, YC_LedOnCallback, &YC_LedBlinkTimerID);
              
              }
              
              void YC_LedStartBlink(bool active, u8_t gpio, u16_t on_time_ms, u16_t off_time_ms)
              {
                      YC_LedBlink.active_state = active;
                      YC_LedBlink.gpio_num = gpio;
                      YC_LedBlink.light_time = on_time_ms;
                      YC_LedBlink.dark_time = off_time_ms;
                      YC_LedOnCallback();
              }
              
              void YC_LedStopBlink(void)
              {
                      YC_LedOff(YC_LedBlink.gpio_num, YC_LedBlink.active_state);
                      YC_UtilTimerStop(YC_LedBlinkTimerID);
              }
              #endif
 282          
 283          /*==============UART======================================================================*/
 284          #ifdef YC_PERIPHERAL_UART
 285          #if 0
              void YC_UARTInit(YC_UARTPARAM_t* param)
              {
                      u16_t baud;
                      u32_t BaseBaud = 48000000;
                      REG_GPIO_SELECT(1) |= BIT(2);           //set GPIO[7:6] as UART pin
              
                      if(param->baud <=12000)
                      {
                              REG_UART_CLK_SEL &= 0xfe;       //use 24Mhz crystal
                              BaseBaud = BaseBaud/2;
                      }
                      else
                              REG_UART_CLK_SEL |= 1;  //use 48Mhz DPLL
              
                      //RX buffer and R/W pointer setting
                      REG_UART_RX_ADDR_S = ESWAP((short)param->pRxBuff);
                      REG_UART_RX_ADDR_E = ESWAP((short)param->pRxBuff + param->rxBuffLen - 1);
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 6   

                      REG_UART_RX_PTR_R = REG_UART_RX_ADDR_S;
              
                      //TX buffer and R/W pointer setting
                      REG_UART_TX_ADDR_S = ESWAP((short)param->pTxBuff);
                      REG_UART_TX_ADDR_E = ESWAP((short)param->pTxBuff + param->txBuffLen - 1);
                      REG_UART_TX_PTRP_R = REG_UART_TX_ADDR_S;
                      REG_UART_TX_PTR_W = REG_UART_TX_ADDR_S;
              
                      //baud rate setting
                      baud = ESWAP(REG_UART_BAUD);
                      baud &= 0xf000;
                      baud |=((BaseBaud/param->baud)&0x0fff);
                      REG_UART_BAUD = ESWAP(baud);
              
                      REG_CLK_OFF(1) &= ~ BIT(7);             //turn on UART's clock
                      REG_UART_CTRL = param->uartCtrl;                        //UART control
              }
              
              u16_t YC_UARTReciveData(u8_t* pbuff, u16_t len)
              {
                      int i = 0;
                      u8_t xdata* rrptr = (u8_t *)ESWAP(REG_UART_RX_PTR_R);
              
                      if(!ESWAP(REG_UART_RX_ITEMS))
                      {
                              return false;
                      }
              
                      for(i=0;i<len;i++)
                      {
                              memcpy(pbuff++, rrptr++, 1);
              
                              if((short)rrptr == ESWAP(REG_UART_RX_ADDR_E) + 1)               //rrptr reach the end of buffer
                              {
                                      rrptr = (u8_t *)ESWAP(REG_UART_RX_ADDR_S);
                              }
              
                              if((short)rrptr == ESWAP(REG_UART_RX_PTR_W) )   //read all data already
                              {
                                      REG_UART_RX_PTR_R = ESWAP((short)rrptr);
                                      return (i+1);
                              }
                      }
              
                      REG_UART_RX_PTR_R = ESWAP((short)rrptr);
                      return i;
              }
              #endif
 351          void YC_UARTSendData(u8_t* pbuff, u16_t len)
 352          {
 353   1              int i;
 354   1              u8_t *twptr = (u8_t *)ESWAP(REG_UART_TX_PTR_W);
 355   1      
 356   1              for(i=0;i<len;i++)
 357   1              {
 358   2                      xmemcpy(twptr++, pbuff++, 1);
 359   2      
 360   2                      if(((short)twptr-1)==ESWAP(REG_UART_TX_ADDR_E)) //twptr reach the end of buffer
 361   2                      {
 362   3                              REG_UART_TX_PTR_W = REG_UART_TX_ADDR_E;
 363   3                              while(ESWAP(REG_UART_TX_ITEMS));
 364   3                              
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 7   

 365   3                              twptr = (u8_t *)ESWAP(REG_UART_TX_ADDR_S);      //reset twptr
 366   3                      }       
 367   2              }       
 368   1      
 369   1              REG_UART_TX_PTR_W = ESWAP((short)twptr);
 370   1              //YC_UARTWaitSendData();
 371   1      }
 372          
 373          void YC_UARTWaitSendData(void)
 374          {
 375   1              while(ESWAP(REG_UART_TX_ITEMS));
 376   1      }
 377          
 378          u16_t YC_UARTReciveDataExpected(u8_t* pbuff, u16_t len)
 379          {
 380   1              int i = 0;
 381   1              u8_t xdata* rrptr = (u8_t *)ESWAP(REG_UART_RX_PTR_R);
 382   1      
 383   1              if(ESWAP(REG_UART_RX_ITEMS)<len)
 384   1              {
 385   2                      return false;
 386   2              }
 387   1      
 388   1              for(i=0;i<len;i++)
 389   1              {
 390   2                      memcpy(pbuff++, rrptr++, 1);
 391   2      
 392   2                      if((short)rrptr == ESWAP(REG_UART_RX_ADDR_E) + 1)               //rrptr reach the end of buffer
 393   2                      {
 394   3                              rrptr = (u8_t *)ESWAP(REG_UART_RX_ADDR_S);
 395   3                      }
 396   2      
 397   2                      if((short)rrptr == ESWAP(REG_UART_RX_PTR_W) )   //read all data already
 398   2                      {
 399   3                              REG_UART_RX_PTR_R = ESWAP((short)rrptr);
 400   3                              return (i+1);
 401   3                      }
 402   2              }
 403   1      
 404   1              REG_UART_RX_PTR_R = ESWAP((short)rrptr);
 405   1              
 406   1              return len;
 407   1      }
 408          
 409          void YC_UARTClearBuffer(void)
 410          {
 411   1              REG_UART_RX_PTR_R = REG_UART_RX_PTR_W;
 412   1              //REG_UART_TX_PTR_W = REG_UART_TX_PTR_R;
 413   1      }
 414          #endif
 415           /*==============PWM======================================================================*/
 416          #ifdef YC_PERIPHERAL_PWM
              void YC_PWMInitClock()
              {
                      REG_PWM_CLK_SEL &= ~(0x11 << 6);
                      REG_PWM_CLK_SEL |= 1 << 6;                              //select PWM clock: system clock undivided 48Mhz
                      REG_CLK_OFF(1) &= ~(1 << PWM_CLOCK);    //turn on PWM clock
              }
              
              void YC_PWMCloseClock()
              {       
                      REG_CLK_OFF(1) |= 1 << PWM_CLOCK;       //turn off PWM clock    
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 8   

              }
              
              /*
              void YC_PWMConfig(YC_PWMChanel_e PWMChSel, u32_t PWM_Freq, u32_t Duty)
              {
                      u32_t pwm_count_max = 48000000 / PWM_Freq;
                      u16_t PWM_pcnt = 0;
                      u16_t PWM_ncnt = 0;
                      PWM_pcnt = pwm_count_max * Duty / 100;
                      PWM_ncnt = pwm_count_max - PWM_pcnt;    
              
                      switch(PWMChSel){
                      case PWM_CH0:
                              REG_PWM_PCOUNT(0) = PWM_pcnt & 0xff;
                              *(&REG_PWM_PCOUNT(0)+1) = PWM_pcnt >> 8 & 0xff;         //set positive pulse clock count
                              REG_PWM_NCOUNT(0) = PWM_ncnt & 0xff;                            
                              *(&REG_PWM_NCOUNT(0)+1) = PWM_ncnt >> 8 & 0xff;         //set npositive pulse clock count
                      break;
                      case PWM_CH1:
                              REG_PWM_PCOUNT(1) = PWM_pcnt & 0xff;
                              *(&REG_PWM_PCOUNT(1)+1) = PWM_pcnt >> 8 & 0xff;     //set positive pulse clock count
                              REG_PWM_NCOUNT(1) = PWM_ncnt & 0xff;
                              *(&REG_PWM_NCOUNT(1)+1) = PWM_ncnt >> 8 & 0xff;     //set npositive pulse clock count
                              break;
                      default:
                              break;
                      }
              }
              */
              
              void YC_PWMConfig(YC_PWMChanel_e PWMChSel, u16_t PWM_pcnt, u16_t PWM_ncnt)
              {
                      switch(PWMChSel){
                      case PWM_CH0:
                              REG_PWM_PCOUNT(0) = PWM_pcnt & 0xff;
                              *(&REG_PWM_PCOUNT(0)+1) = PWM_pcnt >> 8 & 0xff;         //set positive pulse clock count
                              REG_PWM_NCOUNT(0) = PWM_ncnt & 0xff;                            
                              *(&REG_PWM_NCOUNT(0)+1) = PWM_ncnt >> 8 & 0xff;         //set npositive pulse clock count
                              break;
                      case PWM_CH1:
                              REG_PWM_PCOUNT(1) = PWM_pcnt & 0xff;
                              *(&REG_PWM_PCOUNT(1)+1) = PWM_pcnt >> 8 & 0xff;     //set positive pulse clock count
                              REG_PWM_NCOUNT(1) = PWM_ncnt & 0xff;
                              *(&REG_PWM_NCOUNT(1)+1) = PWM_ncnt >> 8 & 0xff;     //set npositive pulse clock count
                              break;
                      default:
                              break;
                      }               
              }
              
              void YC_PWMEnableChanel(YC_PWMChanel_e PWMChSel)
              {
                      switch(PWMChSel){
                      case PWM_CH0:
                              REG_PWM_ENABLE |= 1 << 6;
                              break;
                      case PWM_CH1:
                              REG_PWM_ENABLE |= 1 << 7;
                                      break;
                      default:
                              break;
                      }
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 9   

              }
              
              void YC_PWMDisableChanel(YC_PWMChanel_e PWMChSel)
              {
                      switch(PWMChSel){
                      case PWM_CH0:
                              REG_PWM_ENABLE &= ~(1 << 6);
                              break;
                      case PWM_CH1:
                              REG_PWM_ENABLE &= ~(1 << 7);
                                      break;
                      default:
                              break;
                      }
              }
              
              void YC_PWMOpenChanel(YC_PWMChanel_e PWMChSel, u8_t gpio)
              {
                      u8_t lebit = 7;
                      switch(PWMChSel){
                      case PWM_CH0:
                              switch(gpio){                                                                           //open PWM0 output pin
                                      case 4:
                                              REG_GPIO_SELECT(1) |= 1 << 6;
                                              break;
                                      case 3:
                                              lebit--;
                                      case 6:
                                              lebit--;
                                      case 7:
                                              lebit--;
                                      case 18:
                                              lebit--;
                                      case 19:
                                              lebit--;
                                      case 20:
                                              lebit--;
                                      case 21:
                                              lebit--;
                                      case 22:
                                              REG_GPIO_SELECT(2) |= 1 << lebit;                 
                                              break;
                                      default:
                                              break;
                              }
                              break;
                      case PWM_CH1:
                              REG_GPIO_SELECT(1) |= 1 << 7;                                           //open PWM1 output pin
                              break;
                      default:
                              break;
                      }
              }
              
              void YC_PWMCloseChanel(u8_t gpio)
              {
                      u8_t lebit = 7;
              
                      switch(gpio){
                              case 5:
                                      REG_GPIO_SELECT(1) &= ~(1 << 7);                                        //close PWM1 output pin
                                      break;                  
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 10  

                              case 4:                                                                                                 //close PWM0 output pin
                                      REG_GPIO_SELECT(1) &= ~(1 << 6);
                                      break;
                              case 3:
                                      lebit--;
                              case 6:
                                      lebit--;
                              case 7:
                                      lebit--;
                              case 18:
                                      lebit--;
                              case 19:
                                      lebit--;
                              case 20:
                                      lebit--;
                              case 21:
                                      lebit--;
                              case 22:
                                      REG_GPIO_SELECT(2) &= ~(1 << lebit);                            //close PWM0 output pin
                                      break;
                              default:
                                      break;
                      }
              }
              #endif
 576          
 577           /*==============TIME======================================================================*/
 578          #ifdef YC_PERIPHERAL_TIME
               void YC_Time0Init(void)
               {
                      TMOD = (TMOD&0xf0) |0x01;
                      TH0 = (65536-60000)/256;
                      TL0 = (65536-60000)%256;
                      ET0 = 1;
                      EA = 1;
               }
              
               void YC_Time1Init(void)
               {
                      TMOD = (TMOD&0x0f) |0x10;
                      TH1 = (65536-60000)/256;
                      TL1 = (65536-60000)%256;
                      ET1 = 1;
                      EA = 1;
               }
              
              void YC_TimeStart(YC_TimeChanel_e time_num)
              {
                      switch(time_num){
                              case Time0:
                                      TR0 = 1;
                                      break;
                              case Time1:
                                      TR1 = 1;
                                      break;
                              case Time2:
                                      break;
                              default:
                                      break;
                      }
              }
              
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 11  

              void YC_TimeClose(YC_TimeChanel_e time_num)
              {
                      switch(time_num){
                              case Time0:
                                      TR0 = 0;
                                      ET0 = 0;
                                      break;
                              case Time1:
                                      TR1 = 0;
                                      ET1 = 0;
                                      break;
                              case Time2:
                                      break;
                              default:
                                      break;
                      }
              }
              #endif
 631          
 632          /*==============MATH======================================================================*/
 633          #ifdef YC_PERIPHERAL_MATH
              static void YC_Wait_Cordic()    {while(!(HREAD(PERF_STATUS) & 1 << 2));}
              
              double YC_Cordica(double x, byte type)
              {
                      byte i, t[4];
                      u32_t a = 0;
                      if(type == YC_TYPE_ASIN)
                              a = (u32_t)(x*YC_GAIN);
                      else
                              a = (u32_t)(x*YC_MAG);
                              
                      REG_CLK_OFF(0) &= ~(1 << 5);
              
                      if(type == YC_TYPE_TAN)
                              HWRITE(CORDIC_TYPE, YC_TYPE_SIN << 4);
                      else
                              HWRITE(CORDIC_TYPE, type << 4);
                      *(u32_t*)t = a;
                      for(i = 0;i < 4;i++)
                              HWRITE(CORDIC_A + i, t[3 - i]);
                      YC_Wait_Cordic();
                      if(type == YC_TYPE_TAN) {
                              HWRITE(CORDIC_TYPE, type << 4);
                              HWRITE(CORDIC_A + 3, 0);
                              YC_Wait_Cordic();
                      }
                      for(i = 0;i < 4;i++)
                              t[3 - i] = HREAD(CORDIC_RESULT + i);
              
                      REG_CLK_OFF(0) |= 1 << 5;       
                      if(type == YC_TYPE_ASIN)
                              return (double)(*(u32_t*)t)/YC_GAIN;
                      else
                              return (double)(*(u32_t*)t)/YC_MAG;
              } 
              
              double YC_Cordicab(double x, double y, byte type)
              {
                      byte i, t[4];
                      u32_t a = (u32_t)(x * YC_MAG);
                      u32_t b = (u32_t)(y * YC_MAG);
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 12  

                      REG_CLK_OFF(0) &= ~(1 << 5);
                      
                      HWRITE(CORDIC_TYPE, type << 4);
                      *(u32_t*)t = b;
                      for(i = 0;i < 4;i++)
                              HWRITE(CORDIC_B + i, t[3 - i]);
                      *(u32_t*)t = a;
                      for(i = 0;i < 4;i++)
                              HWRITE(CORDIC_A + i, t[3 - i]);
                      YC_Wait_Cordic();
                      for(i = 0;i < 4;i++)
                              t[3 - i] = HREAD(CORDIC_RESULT + i);
              
                      REG_CLK_OFF(0) |= 1 << 5;       
                      return (double)(*(u32_t*)t)/YC_MAG;
              }
              
              double YC_Arcsin(double x)
              {
                      if (x<0.0761718750)
                              return x;
                      else if ((x>0.1992187500) & (x<0.1997070313))
                              return YC_CompensateArcsin(x,0.1992187500,0.1997070313,0.2005606256,0.2010589199);              
                      else if ((x>0.3034667969) & (x<0.3122558594))
                              return YC_CompensateArcsin(x,0.3034667969,0.3122558594,0.3083289318,0.3175667024);      
                      else if ((x>0.4267578125) & (x<0.4282226563))
                              return YC_CompensateArcsin(x,0.4267578125,0.4282226563,0.4409046923,0.4425250592);      
                      else if ((x>0.4831542969) & (x<0.4836425781))
                              return YC_CompensateArcsin(x,0.4831542969,0.4836425781,0.5042538530,0.5048116334);      
                      else if ((x>0.5312500000) & (x<0.5366210938))
                              return YC_CompensateArcsin(x,0.5312500000,0.5366210938,0.5600753062,0.5664277055);      
                      else if ((x>0.5876464844) & (x<0.5881347656))
                              return YC_CompensateArcsin(x,0.5876464844,0.5881347656,0.6281470148,0.6287506208);      
              
                      else if ((x>0.6071777344) & (x<=0.6267089844))
                              return YC_CompensateArcsin(x,0.6071777344,0.6267089844,0.6525037913,0.6773227088);      
                      else if ((x>0.6267089844) & (x<=0.6462402344))
                              return YC_CompensateArcsin(x,0.6267089844,0.6462402344,0.6773227088,0.7026473527);
                      else if ((x>0.6462402344) & (x<=0.6657714844))
                              return YC_CompensateArcsin(x,0.6462402344,0.6657714844,0.7026473527,0.7285272872);
                      else if ((x>0.6657714844) & (x < 0.6853027344))
                              return YC_CompensateArcsin(x,0.6657714844,0.6853027344,0.7285272872,0.7550193140);
              
                              
                      else if ((x>0.7287597656) & (x<0.7292480469))
                              return YC_CompensateArcsin(x,0.7287597656,0.7292480469,0.8165090300,0.8172223602) ;     
                      else if ((x>0.7500000000) & (x<0.7504882813))
                              return YC_CompensateArcsin(x,0.7500000000,0.7504882813,0.8480620790,0.8488006001);      
                      else if ((x>0.7683105469) & (x<0.7705078125))
                              return YC_CompensateArcsin(x,0.7683105469,0.7705078125,0.8761975022,0.8796374240);      
                      else if ((x>0.8081054688) & (x<0.8088378906))
                              return YC_CompensateArcsin(x,0.8081054688,0.8088378906,0.9409286670,0.9421731504);      
                      else if ((x>0.8264160156) & (x<0.8269042969))
                              return YC_CompensateArcsin(x,0.8264160156,0.8269042969,0.9727124357,0.9735801806) ;     
                      else if ((x>0.8349609375) & (x<0.8435058594))
                              return YC_CompensateArcsin(x,0.8349609375,0.8435058594,0.9880617986,1.0037772973) ;     
                      else if ((x>0.8593750000) & (x<0.8598632813))
                              return YC_CompensateArcsin(x,0.8593750000,0.8598632813,1.0340461496,1.0350018114);
                      else if ((x>0.8745117188) & (x<0.8754882813))
                              return YC_CompensateArcsin(x,0.8745117188,0.8754882813,1.0644281445,1.0664453271) ;
                      else if ((x>0.8896484375) & (x<0.8901367188))
                              return YC_CompensateArcsin(x,0.8896484375,0.8901367188,1.0965747116,1.0976451051);
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 13  

                      else if ((x>0.9013671875) & (x<0.9038085938))
                              return YC_CompensateArcsin(x,0.9013671875,0.9038085938,1.1229162861,1.1285874144);
              
                      else if ((x>0.9106445313) & (x<=0.9167480469))
                              return YC_CompensateArcsin(x,0.9106445313,0.9167480469,1.1448412785,1.1598621394);
                      else if ((x>0.9167480469) & (x<=0.9228515625))
                              return YC_CompensateArcsin(x,0.9167480469,0.9228515625,1.1598621394,1.1754196810);
                      else if ((x>0.9228515625) & (x<=0.9289550781))
                              return YC_CompensateArcsin(x,0.9228515625,0.9289550781,1.1754196810,1.1915801278);
                      else if ((x>0.9289550781) & (x<=0.9350585938))
                              return YC_CompensateArcsin(x,0.9289550781,0.9350585938,1.1915801278,1.2084243173);
                      else if ((x>0.9350585938) & (x<=0.9392089844))
                              return YC_CompensateArcsin(x,0.9350585938,0.9392089844,1.2084243173,1.2203191539);
                      else if ((x>0.9392089844) & (x<=0.9433593750))
                              return YC_CompensateArcsin(x,0.9392089844,0.9433593750,1.2203191539,1.2326142913);
                      else if ((x>0.9433593750) & (x<0.9475097656))
                              return YC_CompensateArcsin(x,0.9433593750,0.9475097656,1.2326142913,1.2453551596);
              
                              
                      else if ((x>0.9565429688) & (x<0.9570312500))
                              return YC_CompensateArcsin(x,0.9565429688,0.9570312500,1.2749062027,1.2765853674) ;
                      else if ((x>0.9648437500) & (x<0.9655761719))
                              return YC_CompensateArcsin(x,0.9648437500,0.9655761719,1.3048482231,1.3076493663);
                      else if ((x>0.9772949219) & (x<0.9799804688))
                              return YC_CompensateArcsin(x,0.9772949219,0.9799804688,1.3572944661,1.3703633600);
              
                      else if ((x>0.9865722656) & (x<=0.9885253906))
                              return YC_CompensateArcsin(x,0.9865722656,0.9885253906,1.4067360140,1.4191610986);
                      else if ((x>0.9885253906) & (x<=0.9904785156))
                              return YC_CompensateArcsin(x,0.9885253906,0.9904785156,1.4191610986,1.4326903339);
                      else if ((x>0.9904785156) & (x<=0.9924316406))
                              return YC_CompensateArcsin(x,0.9904785156,0.9924316406,1.4326903339,1.4476872259);
                      else if ((x>0.9924316406) & (x<=0.9943847656))
                              return YC_CompensateArcsin(x,0.9924316406,0.9943847656,1.4476872259,1.4647727690);
                      else if ((x>0.9943847656) & (x<=0.9963378906))
                              return YC_CompensateArcsin(x,0.9943847656,0.9963378906,1.4647727690,1.4851885382);
                      else if ((x>0.9963378906) & (x<=0.9982910156))
                              return YC_CompensateArcsin(x,0.9963378906,0.9982910156,1.4851885382,1.5123246008);
                      else if ((x>0.9982910156) & (x<=1.0000000000))
                              return YC_CompensateArcsin(x,0.9982910156,1.0000000000,1.5123246008,1.5707963268);
              
                      else
                              return YC_Cordica(x,YC_TYPE_ASIN);
              }
              
              static double YC_CompensateArcsin(double parameter,double c1,double c2,double a1, double a2)
              {       
                      return a1 + (parameter -c1) *(a2 -a1) /(c2 -c1);
              }
              
              #endif
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 14  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _YC_GPIOGetInputStatus (BEGIN)
                                           ; SOURCE LINE # 140
;---- Variable 'gpio_num' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 141
                                           ; SOURCE LINE # 144
                       MOV     A,R7
                       ANL     A,#07H
                       MOV     R6,A
;---- Variable 'queue' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 145
                       MOV     A,R7
                       RRC     A
                       RRC     A
                       RRC     A
                       ANL     A,#03H
                       MOV     R7,A
;---- Variable 'group' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 147
                       ADD     A,#01CH
                       MOV     R5,A
                       CLR     A
                       ADDC    A,#081H
                       MOV     DPL,R5
                       MOV     DPH,A
                       MOVX    A,@DPTR
                       MOV     R5,A
                       MOV     R4,#00H
                       MOV     R7,AR6
                       MOV     A,#01H
                       MOV     R6,#00H
                       MOV     R0,AR7
                       INC     R0
                 R     xJMP    ?C0021
             ?C0020:
                       CLR     C
                       RLC     A
                       XCH     A,R6
                       RLC     A
                       XCH     A,R6
             ?C0021:
                 R     DJNZ    R0,?C0020
                       MOV     R7,A
                       MOV     A,R6
                       ANL     A,R4
                       MOV     R6,A
                       MOV     A,R7
                       ANL     A,R5
                       ORL     A,R6
                       ADD     A,#0FFH
                                           ; SOURCE LINE # 148
             ?C0001:
                       RET     
             ; FUNCTION _YC_GPIOGetInputStatus (END)

             ; FUNCTION _YC_UARTSendData (BEGIN)
                                           ; SOURCE LINE # 351
                 R     MOV     DPTR,#pbuff
                       MOV     A,R3
                       MOVX    @DPTR,A
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 15  

                       INC     DPTR
                       MOV     A,R2
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R1
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R4
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R5
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 352
                                           ; SOURCE LINE # 354
                       MOV     DPTR,#0805EH
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,A
                       MOV     DPTR,#0805EH
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,R4
                       MOV     R6,A
                       MOV     A,R7
                       MOV     R2,AR6
                       MOV     R1,A
                 R     MOV     DPTR,#twptr
                       CLR     A
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R2
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R1
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 356
                       CLR     A
                 R     MOV     DPTR,#i
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOVX    @DPTR,A
             ?C0002:
                 R     MOV     DPTR,#len
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R7,A
                       CLR     C
                 R     MOV     DPTR,#i+01H
                       MOVX    A,@DPTR
                       SUBB    A,R7
                 R     MOV     DPTR,#i
                       MOVX    A,@DPTR
                       SUBB    A,R6
                 R     xJGE    ?C0003
                                           ; SOURCE LINE # 357
                                           ; SOURCE LINE # 358
                 R     MOV     DPTR,#twptr
                       MOVX    A,@DPTR
                       INC     DPTR
                       CLR     A
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 16  

                       MOV     B,#01H
                 E     CALL    ?C?ILDIX
                       MOV     R6,A
                       MOV     R7,B
                 R     MOV     DPTR,#pbuff
                       MOVX    A,@DPTR
                       MOV     R3,A
                       INC     DPTR
                       CLR     A
                       MOV     B,#01H
                 E     CALL    ?C?ILDIX
                       MOV     R1,B
                       MOV     R2,A
                 E     MOV     ?_xmemcpy?BYTE+05H,#01H
                 E     CALL    _xmemcpy
                                           ; SOURCE LINE # 360
                       MOV     DPTR,#0805CH
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,A
                       MOV     DPTR,#0805CH
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,R4
                       MOV     R6,A
                       MOV     A,R7
                 R     MOV     DPTR,#twptr
                       MOVX    A,@DPTR
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R2,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       ADD     A,#0FFH
                       MOV     R5,A
                       MOV     A,R2
                       ADDC    A,#0FFH
                       MOV     R4,A
                       MOV     A,R7
                       XRL     A,R5
                 R     JNZ     ?C0022
                       MOV     A,R6
                       XRL     A,R4
             ?C0022:
                 R     xJNZ    ?C0004
                                           ; SOURCE LINE # 361
                                           ; SOURCE LINE # 362
                       MOV     DPTR,#0805CH
                       MOVX    A,@DPTR
                       MOV     R7,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       INC     DPTR
                       XCH     A,R7
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R7
                       MOVX    @DPTR,A
             ?C0006:
                                           ; SOURCE LINE # 363
                       MOV     DPTR,#0810EH
                       INC     DPTR
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 17  

                       MOVX    A,@DPTR
                       MOV     R4,A
                       MOV     DPTR,#0810EH
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,R4
                       MOV     R6,A
                       MOV     A,R7
                       ORL     A,R6
                 R     xJNZ    ?C0006
             ?C0007:
                                           ; SOURCE LINE # 365
                       MOV     DPTR,#0805AH
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,A
                       MOV     DPTR,#0805AH
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,R4
                       MOV     R6,A
                       MOV     A,R7
                       MOV     R2,AR6
                       MOV     R1,A
                 R     MOV     DPTR,#twptr
                       CLR     A
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R2
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R1
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 367
             ?C0004:
                 R     MOV     DPTR,#i+01H
                       MOVX    A,@DPTR
                       INC     A
                       MOVX    @DPTR,A
                 R     JNZ     ?C0023
                 R     MOV     DPTR,#i
                       MOVX    A,@DPTR
                       INC     A
                       MOVX    @DPTR,A
             ?C0023:
                 R     xJMP    ?C0002
             ?C0003:
                                           ; SOURCE LINE # 369
                 R     MOV     DPTR,#twptr
                       MOVX    A,@DPTR
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R2,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,AR2
                       MOV     R5,A
                       MOV     A,R4
                       MOV     R7,A
                       RLC     A
                       SUBB    A,ACC
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 18  

                       MOV     R3,AR7
                       MOV     A,R5
                       MOV     R7,A
                       MOV     A,R3
                       MOV     DPTR,#0805EH
                       XCH     A,R7
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 371
                       RET     
             ; FUNCTION _YC_UARTSendData (END)

             ; FUNCTION YC_UARTWaitSendData (BEGIN)
                                           ; SOURCE LINE # 373
                                           ; SOURCE LINE # 374
             ?C0009:
                                           ; SOURCE LINE # 375
                       MOV     DPTR,#0810EH
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,A
                       MOV     DPTR,#0810EH
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,R4
                       MOV     R6,A
                       MOV     A,R7
                       ORL     A,R6
                 R     xJNZ    ?C0009
             ?C0010:
                                           ; SOURCE LINE # 376
             ?C0011:
                       RET     
             ; FUNCTION YC_UARTWaitSendData (END)

             ; FUNCTION _YC_UARTReciveDataExpected (BEGIN)
                                           ; SOURCE LINE # 378
                 R     MOV     DPTR,#pbuff
                       MOV     A,R3
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R2
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R1
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R4
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R5
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 379
                                           ; SOURCE LINE # 380
                       CLR     A
                       INC     DPTR
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 381
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 19  

                       MOV     DPTR,#08058H
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,A
                       MOV     DPTR,#08058H
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,R4
                       MOV     R6,A
                       MOV     A,R7
                 R     MOV     DPTR,#rrptr
                       MOV     A,R6
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 383
                       MOV     DPTR,#08112H
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,A
                       MOV     DPTR,#08112H
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,R4
                       MOV     R6,A
                       MOV     A,R7
                       SETB    C
                 R     MOV     DPTR,#len+01H
                       MOVX    A,@DPTR
                       SUBB    A,R7
                 R     MOV     DPTR,#len
                       MOVX    A,@DPTR
                       SUBB    A,R6
                 R     xJLT    ?C0012
                                           ; SOURCE LINE # 384
                                           ; SOURCE LINE # 385
                       CLR     A
                       MOV     R6,A
                       MOV     R7,A
                       RET     
                                           ; SOURCE LINE # 386
             ?C0012:
                                           ; SOURCE LINE # 388
                       CLR     A
                 R     MOV     DPTR,#i
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOVX    @DPTR,A
             ?C0014:
                 R     MOV     DPTR,#len
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R7,A
                       CLR     C
                 R     MOV     DPTR,#i+01H
                       MOVX    A,@DPTR
                       SUBB    A,R7
                 R     MOV     DPTR,#i
                       MOVX    A,@DPTR
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 20  

                       SUBB    A,R6
                 R     xJGE    ?C0015
                                           ; SOURCE LINE # 389
                                           ; SOURCE LINE # 390
                 R     MOV     DPTR,#rrptr
                       CLR     A
                       MOV     B,#01H
                 E     CALL    ?C?ILDIX
                       MOV     R2,A
                       MOV     R1,B
                       MOV     R3,#01H
                       PUSH    AR3
                 R     MOV     DPTR,#pbuff
                       MOVX    A,@DPTR
                       MOV     R3,A
                       INC     DPTR
                       CLR     A
                       MOV     B,#01H
                 E     CALL    ?C?ILDIX
                       MOV     R0,B
                       MOV     R4,A
                       MOV     R5,AR3
                       POP     AR3
                       MOV     R6,#00H
                       MOV     R7,#01H
                 E     CALL    ?C?COPY
                                           ; SOURCE LINE # 392
                       MOV     DPTR,#08056H
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,A
                       MOV     DPTR,#08056H
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,R4
                       MOV     R6,A
                       MOV     A,R7
                       ADD     A,#01H
                       MOV     R7,A
                       CLR     A
                       ADDC    A,R6
                       MOV     R6,A
                 R     MOV     DPTR,#rrptr
                       MOVX    A,@DPTR
                       MOV     R4,A
                       INC     DPTR
                       MOVX    A,@DPTR
                 R     xJNE    A,AR7,?C0017
                       MOV     A,R6
                 R     xJNE    A,AR4,?C0017
                                           ; SOURCE LINE # 393
                                           ; SOURCE LINE # 394
                       MOV     DPTR,#08054H
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,A
                       MOV     DPTR,#08054H
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,R4
                       MOV     R6,A
                       MOV     A,R7
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 21  

                 R     MOV     DPTR,#rrptr
                       MOV     A,R6
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 395
             ?C0017:
                                           ; SOURCE LINE # 397
                       MOV     DPTR,#08116H
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R4,A
                       MOV     DPTR,#08116H
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,R4
                       MOV     R6,A
                       MOV     A,R7
                 R     MOV     DPTR,#rrptr
                       MOVX    A,@DPTR
                       MOV     R4,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R5,A
                       MOV     A,R7
                       XRL     A,R5
                 R     JNZ     ?C0025
                       MOV     A,R6
                       XRL     A,R4
             ?C0025:
                 R     xJNZ    ?C0016
                                           ; SOURCE LINE # 398
                                           ; SOURCE LINE # 399
                 R     MOV     DPTR,#rrptr
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     A,R4
                       MOV     R7,A
                       RLC     A
                       SUBB    A,ACC
                       MOV     R3,AR7
                       MOV     A,R5
                       MOV     R7,A
                       MOV     A,R3
                       MOV     DPTR,#08058H
                       XCH     A,R7
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 400
                 R     MOV     DPTR,#i+01H
                       MOVX    A,@DPTR
                       ADD     A,#01H
                       MOV     R7,A
                 R     MOV     DPTR,#i
                       MOVX    A,@DPTR
                       ADDC    A,#00H
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 22  

                       MOV     R6,A
                       RET     
                                           ; SOURCE LINE # 401
                                           ; SOURCE LINE # 402
             ?C0016:
                 R     MOV     DPTR,#i+01H
                       MOVX    A,@DPTR
                       INC     A
                       MOVX    @DPTR,A
                 R     JNZ     ?C0026
                 R     MOV     DPTR,#i
                       MOVX    A,@DPTR
                       INC     A
                       MOVX    @DPTR,A
             ?C0026:
                 R     xJMP    ?C0014
             ?C0015:
                                           ; SOURCE LINE # 404
                 R     MOV     DPTR,#rrptr
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R7,A
                       MOV     R5,A
                       MOV     R4,AR6
                       MOV     A,R4
                       MOV     R7,A
                       RLC     A
                       SUBB    A,ACC
                       MOV     R3,AR7
                       MOV     A,R5
                       MOV     R7,A
                       MOV     A,R3
                       MOV     DPTR,#08058H
                       XCH     A,R7
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 406
                 R     MOV     DPTR,#len
                       MOVX    A,@DPTR
                       MOV     R6,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     R7,A
                                           ; SOURCE LINE # 407
             ?C0013:
                       RET     
             ; FUNCTION _YC_UARTReciveDataExpected (END)

             ; FUNCTION YC_UARTClearBuffer (BEGIN)
                                           ; SOURCE LINE # 409
                                           ; SOURCE LINE # 410
                                           ; SOURCE LINE # 411
                       MOV     DPTR,#08116H
                       MOVX    A,@DPTR
                       MOV     R7,A
                       INC     DPTR
                       MOVX    A,@DPTR
                       MOV     DPTR,#08058H
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 23  

                       XCH     A,R7
                       MOVX    @DPTR,A
                       INC     DPTR
                       MOV     A,R7
                       MOVX    @DPTR,A
                                           ; SOURCE LINE # 413
                       RET     
             ; FUNCTION YC_UARTClearBuffer (END)

C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 24  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
s8_t . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
SM01 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
u8_t . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
SM11 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
UART_CardProtcol . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
YC_UARTPARAM_t . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  15
  uartCtrl . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  pRxBuff. . . . . . . . . . . . . . .  MEMBER   -----  PTR      0001H  3
  pTxBuff. . . . . . . . . . . . . . .  MEMBER   -----  PTR      0004H  3
  rxBuffLen. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0007H  2
  txBuffLen. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0009H  2
  baud . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   000BH  4
SM21 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
T0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
AC . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
YC_UARTClearBuffer . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
T1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
pxdbyte. . . . . . . . . . . . . . . .  TYPEDEF  DATA   PTR      -----  2
T2 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
YC_LedBlink. . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  active_state . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  gpio_num . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  light_time . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  dark_time. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
_xmemcpy . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
pdbyte . . . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  1
DPH1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
FL . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
DPL1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
UART_HalfDuplex. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
TA . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
EXF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
RD . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
REN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
DFIFO0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
RI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
UART_Parity. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DFIFO1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
dbyte. . . . . . . . . . . . . . . . .  TYPEDEF  DATA   U_CHAR   -----  1
INT0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
CY . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
DFIFO2 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
TI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
INT1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
SADEN0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
INT2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
SADEN1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
RXD0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 25  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


INT3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
RXD1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
INT4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
SADDR0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
pxbyte . . . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  2
ibyte. . . . . . . . . . . . . . . . .  TYPEDEF  IDATA  U_CHAR   -----  1
TXD0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
INT5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
SADDR1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
TXD1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
RCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
T2EX . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
EPFI . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DDH  1
OV . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
RCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
C_T2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
WR . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
EWDI . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
WDIF . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
RCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
EXIF . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
s32_t. . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
YC_UARTPARAM . . . . . . . . . . . . .  * TAG *  -----  STRUCT   -----  15
  uartCtrl . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  pRxBuff. . . . . . . . . . . . . . .  MEMBER   -----  PTR      0001H  3
  pTxBuff. . . . . . . . . . . . . . .  MEMBER   -----  PTR      0004H  3
  rxBuffLen. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0007H  2
  txBuffLen. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0009H  2
  baud . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   000BH  4
bool . . . . . . . . . . . . . . . . .  TYPEDEF  DATA   BIT      -----  1
TCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CCH  1
u32_t. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
s16_t. . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
xbyte. . . . . . . . . . . . . . . . .  TYPEDEF  XDATA  U_CHAR   -----  1
PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
u16_t. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
dint . . . . . . . . . . . . . . . . .  TYPEDEF  DATA   U_INT    -----  2
PWDI . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FCH  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
byte . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
YC_UartCTRLBit_e . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
UART_DataLen . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
IE0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
IE1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
uint . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
WTRF . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
CP_RL2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
_YC_UARTSendData . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  pbuff. . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  len. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0003H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  INT      0005H  2
  twptr. . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0007H  3
SMOD_1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 26  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ES0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
ES1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
UART_BaudSet . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
ET2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
TF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
TF2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
RI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
RB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
EX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
IT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
TI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
TB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
EX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
IT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
TH2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
EX2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
P. . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
EX3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
SM0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
EX4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
SM1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
EX5. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
SM2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
TL2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
_YC_UARTReciveDataExpected . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  pbuff. . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  len. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0003H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  INT      0005H  2
  rrptr. . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0007H  2
PS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
EIE. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
PT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
PS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
PT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
RS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
PT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
RS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
PX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
PX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
PX2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
PX3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
YC_LedBlink_t. . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  active_state . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  gpio_num . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  light_time . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  dark_time. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
PX4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
C51 COMPILER V9.01   YC_PERIPHERAL                                                         03/23/2017 16:16:35 PAGE 27  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
YC_UARTWaitSendData. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PX5. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FBH  1
EIP. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
PFI. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C1H  1
EXEN2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
REN. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
STATUS . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
T2MOD. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
DPS. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
UART_Enable. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
UART_EnableFlowControl . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_YC_GPIOGetInputStatus . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  gpio_num . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  queue. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  group. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
CKCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
EWT. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
POR. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
YC_UartCTRLBit . . . . . . . . . . . .  * TAG *  -----  ENUM     -----  -----
F0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
F1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
WDCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
RWT. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
RB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    702    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
